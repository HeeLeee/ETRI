--SET 연산자
SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
UNION
SELECT EMPLOYEE_ID, JOB_ID
FROM JOB_HISTORY
ORDER BY EMPLOYEE_ID;
--SET ALL
SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
UNION ALL
SELECT EMPLOYEE_ID, JOB_ID
FROM JOB_HISTORY
ORDER BY EMPLOYEE_ID;
--INTERSECT
SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
INTERSECT
SELECT EMPLOYEE_ID, JOB_ID
FROM JOB_HISTORY;
--MINUS
SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
MINUS
SELECT EMPLOYEE_ID, JOB_ID
FROM JOB_HISTORY;
--DATETIME
SELECT TZ_OFFSET('US/Eastern') FROM DUAL;

SELECT TZ_OFFSET('ROK') FROM DUAL;
--CURRENT_DATE
--1
CREATE TABLE TDATE(
    D1 DATE);
--2    
ALTER SESSION
SET NLS_DATE_FORMAT = 'YYYY/MM/DD';
--3
INSERT INTO TDATE
SELECT '19970101' FROM DUAL;
--1번 재수행 에러확인
ALTER SESSION 
SET NLS_DATE_FORMAT = 'DD-MON-YYY HH24:MI:SS';

SELECT SYSDATE FROM DUAL;

ALTER SESSION SET TIME_ZONE = '-05:00, 0';
SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL;
--LOCALTIMESTAMP
SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP
FROM DUAL;
--DBTIMEZOINE
SELECT DBTIMEZONE FROM DUAL;
--SESSIONTIMEZONE
SELECT SESSIONTIMEZONE FROM DUAL;
--EXTRACT
SELECT EXTRACT (YEAR FROM SYSDATE) FROM DUAL;
SELECT LAST_NAME, EXTRACT (YEAR FROM HIRE_DATE)
FROM EMPLOYEES
WHERE MANAGER_ID = 100;
--FROM_TZ
SELECT FROM_TZ (TIMESTAMP '2004-03-28 08:00:00', '3:00')
FROM DUAL;
--TO_TIMESTAMP
SELECT TO_TIMESTAMP ('2004-03-28 08:00:00', 'YYYY-MM-DD HH:MI:SS')
FROM DUAL;
SELECT TO_TIMESTAMP_TZ('2004-03-28 08:00:00 -8:00', 'YYYY-MM-DD HH:MI:SS TZH:TZM')
FROM DUAL;
--TO_YMINTERVAL
SELECT HIRE_DATE, HIRE_DATE + TO_YMINTERVAL('01-02')
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

DESC TDEPT;
--1.직원 정보의 사번, 부서코드와 부서정보의 부서장, 부서코드를 중복제거 합집합으로 구해오는 쿼리
SELECT EMP_ID, DEPT_CODE
FROM TEMP
UNION
SELECT BOSS_ID,DEPT_CODE
FROM TDEPT
ORDER BY DEPT_CODE;
SELECT * FROM TDEPT;
--2. 직원 정보의 사번, 부서코드와 부서정보의 부서장, 부서코드를 중복허용 합집합으로 구해오는 쿼리
SELECT EMP_ID, DEPT_CODE
FROM TEMP
UNION ALL
SELECT BOSS_ID,DEPT_CODE
FROM TDEPT;
--3.직원 정보의 사번, 부서코드와 부서정보의 부서장, 부서코드를 중복허용 합집합으로 구해오는 쿼리를 사번별로 SORT
SELECT EMP_ID, DEPT_CODE
FROM TEMP
UNION
SELECT BOSS_ID,DEPT_CODE
FROM TDEPT
ORDER BY EMP_ID;
--4.직원 정보의 사번, 부서코드와 부서정보의 부서장, 부서코드를 교집합으로 구해오는 쿼리
SELECT EMP_ID, DEPT_CODE
FROM TEMP
INTERSECT
SELECT BOSS_ID,DEPT_CODE
FROM TDEPT;
--5. 부서장이 아닌 직원의 사번, 부서코드 구해오는 쿼리
SELECT EMP_ID, DEPT_CODE
FROM TEMP
MINUS
SELECT BOSS_ID,DEPT_CODE
FROM TDEPT;
--6. 사번이 2000년 이후 사번이고, 급여가 3천만원보다 큰 직원의 사번,부서코드, 급여정보와
--  부서테이블의 사번, 부서코드 정보 중 'A'로 시작하는 자료의 합집합을 구하는 쿼리
SELECT EMP_ID, DEPT_CODE
FROM TEMP
WHERE EMP_ID >= 20000000
AND SALARY > 30000000
UNION
SELECT BOSS_ID, DEPT_CODE
FROM TDEPT
WHERE DEPT_CODE LIKE 'A%';
--7.직원정보 백업자료(TEMP1)와 직원정보자료의 교집합을 구하고 거기서 2019년 COMMISION에
--존재하는 직원을 뺀 사번과 부서코드
SELECT EMP_ID
FROM TEMP
INTERSECT
SELECT EMP_ID
FROM TEMP1
MINUS
SELECT EMP_ID
FROM TCOM;
--1.사번별로 급여정보와 커미션 정보를 볼 수 있는 쿼리작성 (OUTER 조인 없이 집합연산자 이용)
SELECT A.EMP_ID, SUM(A.SALARY), SUM(A.COMM)
FROM (
        SELECT EMP_ID, SALARY, 0 COMM FROM TEMP
        UNION
        SELECT EMP_ID, 0 SALARY, COMM FROM TCOM
        ) A
GROUP BY A.EMP_ID;
--2. TEMP와 TCOM에 존재하는 사번의 교집합을 구한 후
--TEMP 에서 TCOM에 존재하는 사번을 제외시킨 차집합을 구하고 두개 결과의합집합을 구해보자 52
SELECT EMP_ID
FROM(
        SELECT EMP_ID
        FROM TEMP
        INTERSECT
        SELECT EMP_ID
        FROM TCOM)
UNION ALL
SELECT EMP_ID
FROM 
    (SELECT EMP_ID
    FROM TEMP
    MINUS
    SELECT EMP_ID
    FROM TCOM);
--3. 첫번째 SELECT에서는 TEMP의 사번화 부서코드를 UNION 뒤 문장에서는 TEMP1의 사번과
--  SALARY를 SELECT하여 UNION으로 결합하고 어떤 에러가 나는지 확인

--4. 첫문장은 사번, 부서코드를 SELECT하고 두번째 문장에서는 사번, 부서코드, SALARY를 SELECT하여 
--UNION으로 결합하고 어던 애러가 나는지 확인
--5. TEMP의 EMP_ID와 TEMP1의 EMP_ID를 UNION, UNIONALL, INTERSECT, MINUS를 각각
--연결하여 어떤집합연산자ㅏ SORT가 일어나는지 확인
--6. 1번 TEMP, 2번 TDEPT 3번 TEMP1에서 (사번 TDEPT는 부서장ID)과
--부서코드를 읽어와 테이블 순서대로 보여주는 쿼리  114
--과제
--1. 한국 표준시간대 확인
SELECT TZ_OFFSET('ROK') FROM DUAL;
--2. 현재 설정된 표준시간대 확인
SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL;
--3. 시간대변경
ALTER SESSION SET TIME_ZONE = '+5:00';
ALTER SESSION SET TIME_ZONE = '+9:00';
--4. 한국의 타임존 확인
SELECT * FROM V$TIMEZONE_NAMES WHERE TZNAME LIKE 'R%';
SELECT * FROM V$TIMEZONE_NAMES WHERE TZNAME LIKE '%Se%';
--5. DATE형 컬럼 1개 짜리 TABLE 생성
CREATE TABLE TDATE (D1 DATE)
--6. 현재 포맷으로 T1에 INSERT
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYYMMDD HH24:MI:SS';
INSERT INTO TDATE VALUES ('');
--7. Date FORMAT 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MM-YYYY';
--8. 변경전 FORMAT으로 입력 오류 확인
INSERT INTO TDATE VALUES('19980101');
--9. 변경후 FORMAT으로 입력
INSERT INTO TDATE VALUES('01-1월-1998');
--10. SYSTIMESTAMP 를 통한 1/100초 확인
SELECT TO_CHAR(SYSTIMESTAMP, 'YYYYMMDD HH24MISS.FF2') FROM DUAL;
--11. DBTIMEZONE 과 SESSIONTIMEZONE 비교
SELECT DBTIMEZONE, SESSIONTIMEZONE FROM DUAL;
--12. SESSIONTIMEZONE 변경 
ALTER SESSION SET TIME_ZONE = '+5:00';
--13. 11번 다시 수행
SELECT DBTIMEZONE, SESSIONTIMEZONE FROM DUAL;
--14. EXTRACT 이용
SELECT EXTRACT (YEAR FROM SYSDATE) FROM DUAL;
SELECT EXTRACT (MONTH FROM SYSDATE) FROM DUAL;
SELECT EXTRACT (DAY FROM SYSDATE) FROM DUAL;
--15. 존재하지 않는 테이블 대상으로 SELECT 실행 후 에러 메시지 확인
SELECT * FROM UUU;
--16. SESSION LANGUAGE AMERICAN으로 변경 변경 후 1번 실행
ALTER SESSION SET NLS_LANGUAGE  = AMERICAN;
--17. SESSION LANGUAGE 를 JAPANESE, GERMAN, ITALIAN, AMERICAN, RUSSIAN 로 바꿔가며 확인
ALTER SESSION SET NLS_LANGUAGE = JAPANESE;
ALTER SESSION SET NLS_LANGUAGE = KOREAN;
--18. SESSION TERRITORY 변경 전 후 SELECT TO_CHAR(SALARY,'L999999999') SALARY FROM TEMP;
SELECT TO_CHAR(SALARY,'L99999999') SALARY FROM TEMP;
--19. SESSION 의 통화를 달러로 변경
SELECT TO_CHAR(SALARY,'$999999999') SALARY FROM TEMP;
--20. 현재 날짜에 1년 3개월을 더한 날짜 (TO_YMINTERVAL 이용)
SELECT SYSDATE, SYSDATE + TO_YMINTERVAL('01-03')
FROM DUAL;
--21. 문자를 TIMESTAMP WITH ZONE 형식으로 변환 출력
SELECT FROM_TZ (TIMESTAMP '2004-03-28 08:00:00', '3:00')
FROM DUAL;
--TEST
CREATE TABLE TEST35 (
    KEY1 VARCHAR2(05),
    KEY2 VARCHAR2(05),
    AMT NUMBER,
    CONSTRAINT TEST35_PK PRIMARY KEY (KEY1,KEY2)
);
INSERT INTO TEST35 VALUES ('0001','A', 500);
INSERT INTO TEST35 VALUES ('0001','B', 400);
INSERT INTO TEST35 VALUES ('0002','A', 400);
INSERT INTO TEST35 VALUES ('0002','B', 300);
INSERT INTO TEST35 VALUES ('0003','A', 600);
INSERT INTO TEST35 VALUES ('0003','B', 400);
INSERT INTO TEST35 VALUES ('0004','A', 700);
INSERT INTO TEST35 VALUES ('0004','B', 300);
INSERT INTO TEST35 VALUES ('0005','A', 800);
INSERT INTO TEST35 VALUES ('0005','B', 200);
INSERT INTO TEST35 VALUES ('0006','A', 700);
INSERT INTO TEST35 VALUES ('0006','B', 600);
COMMIT;
-- A = KEY2의 A에 해당하는 값
-- B = KEY2의 B에 해당하는 값
-- C = A-B
-- PER = 100 * C/A
-- 각 KEY1에 대해서뿐만 아니라 합계에 대해서도 동일한 규칙을 적용한다.
-- 특히 합계 ROW의 PER 값은 001~006의 PER의 합이 아니다.
-- 합계 ROW의 100*C/A를 적용한 값이다.
SELECT * FROM TEST35;

--TEST35 4개쓰기
SELECT A.KEY1 KEY,
    A.AMT A, 
    B.AMT B, 
    A.AMT-B.AMT C, 
    ROUND(100 * ((A.AMT-B.AMT)/A.AMT)) PER
FROM 
    (SELECT KEY1, KEY2, AMT
    FROM TEST35
    WHERE KEY2 = 'A') A,
    (SELECT KEY1, KEY2, AMT
    FROM TEST35
    WHERE KEY2 = 'B') B
WHERE A.KEY1 = B.KEY1
UNION
SELECT '합계', 
    SUM(A.AMT), 
    SUM(B.AMT), 
    SUM(A.AMT-B.AMT), 
    (ROUND(100*((SUM(A.AMT)-SUM(B.AMT))/SUM(A.AMT))))
FROM (SELECT KEY1, KEY2, AMT
    FROM TEST35
    WHERE KEY2 = 'A') A,
    (SELECT KEY1, KEY2, AMT
    FROM TEST35
    WHERE KEY2 = 'B') B
WHERE A.KEY1 = B.KEY1;

--힌트
SELECT NO
FROM T1_DATA
WHERE ROWNUM <= 2;

SELECT EMP_ID, SALARY
FROM TEMP
WHERE DEPT_CODE = 'AA0001';

SELECT NO, EMP_ID, SALARY
FROM TEMP, T1_DATA
WHERE DEPT_CODE = 'AA0001'
AND NO <= 2;

SELECT DECODE(NO,1,TO_CHAR(EMP_ID),'합계') KEY1,
        SUM(SALARY)
FROM TEMP, T1_DATA
WHERE DEPT_CODE = 'AA0001'
AND NO <= 2
GROUP BY DECODE(NO,1,TO_CHAR(EMP_ID),'합계')
ORDER BY 1;

--TEST35 1개 쓰기----------------------------------------------------------------------------------------------------------------
SELECT DECODE(NO,1,TO_CHAR(KEY1),'합계') KEY1,
        SUM(DECODE(KEY2, 'A', AMT)) A,
        SUM(DECODE(KEY2, 'B', AMT)) B,
        SUM(DECODE(KEY2, 'A', AMT)) - SUM(DECODE(KEY2, 'B', AMT)) C,
        ROUND(100 * ((SUM(DECODE(KEY2, 'A', AMT)) - SUM(DECODE(KEY2, 'B', AMT)))/SUM(DECODE(KEY2, 'A', AMT)))) PER
FROM TEST35, T1_DATA
WHERE NO <= 2
GROUP BY DECODE(NO,1,TO_CHAR(KEY1),'합계')
ORDER BY 1;
--------------------------------------------------------------------------------------------------------------------------------
CREATE TABLE TEST04 (
    YMD VARCHAR2(08) NOT NULL,
    US_AMOUNT NUMBER NOT NULL,
    CONSTRAINT TEST04_PK PRIMARY KEY (YMD)
);
CREATE TABLE TEST05 (
    YMD VARCHAR2(08) NOT NULL,
    EXC_RATE NUMBER NOT NULL,
    CONSTRAINT TEST05_PK PRIMARY KEY (YMD)
);
INSERT INTO TEST04 VALUES ('19980102', 3171);
INSERT INTO TEST04 VALUES ('19980203', 3142);
INSERT INTO TEST04 VALUES ('19980304', 3113);
INSERT INTO TEST04 VALUES ('19980405', 3084);
INSERT INTO TEST04 VALUES ('19980701', 3055);
INSERT INTO TEST04 VALUES ('19980802', 3026);
INSERT INTO TEST04 VALUES ('19980903', 2997);
INSERT INTO TEST04 VALUES ('19981004', 2968);
INSERT INTO TEST04 VALUES ('19981102', 2939);
INSERT INTO TEST05 VALUES ('19971231', 1800);
INSERT INTO TEST05 VALUES ('19980630', 1300);
INSERT INTO TEST05 VALUES ('19970630',  800);
INSERT INTO TEST05 VALUES ('19961231',  780);
INSERT INTO TEST05 VALUES ('19980331', 1500);

--TEST04는 일자(YMD)별로 보유 달러금액(US_AMOUNT)을 보관하는 테이블이다.
--TEST05는 반기 또는 분기별로 당시의 환율을 가지고 있다.
SELECT * FROM TEST04;
SELECT * FROM TEST05;
--문제
--TEST04기준 각 RECORD별 일자, 달러금액(#1), TEST05에서 TEST04일자보다 작은 일자중
--최근 일자가 가지고 있는 환율(#2), 원화환산금액(=#1*#2)을 나오도록 쿼리 쿠성
--(단, 2018년 DATA만 대상)
--추출컬럼 : 달러보유일자, 환율기준일자, 보유달러금액, 환율, 환산금액
--4-1 서브쿼리 이용 해결
SELECT A.YMD 달러보유일자, B.YMD 환율기준일자, US_AMOUNT 보유달러금액, EXC_RATE 환율,US_AMOUNT*EXC_RATE 환산금액
FROM TEST04 A, TEST05 B
WHERE B.YMD IN (SELECT MAX(C.YMD)
                FROM TEST05 C
                WHERE A.YMD > C.YMD
                GROUP BY A.YMD);
--4-2 인라인뷰 이용 해결
SELECT Q.YMD 달러보유일자, Q.MX 환율기준일자, Q.US_AMOUNT 보유달러금액, B.EXC_RATE 환율, MAX(Q.US_AMOUNT*B.EXC_RATE) 환산금액
FROM (
       SELECT MAX(B.YMD) MX, A.YMD YMD, A.US_AMOUNT
        FROM TEST04 A,TEST05 B
        WHERE A.YMD > B.YMD
        GROUP BY A.YMD, A.US_AMOUNT) Q,
        TEST05 B
WHERE B.YMD = Q.MX
GROUP BY Q.YMD, Q.MX, Q.US_AMOUNT, B.EXC_RATE
ORDER BY 1;
--2.인라인뷰 2번쨰방법--
SELECT A.YMD 달러보유일자, B.YMD 환율기준일자, A.US_AMOUNT 보유달러금액, B.EXC_RATE 환율, A.US_AMOUNT*B.EXC_RATE 환산금액
FROM(
        SELECT MAX(B.YMD) MX, A.YMD YMD
        FROM TEST04 A,TEST05 B
        WHERE A.YMD > B.YMD
        GROUP BY A.YMD) X,
        TEST04 A, TEST05 B
WHERE X.MX = B.YMD AND X.YMD = A.YMD
ORDER BY 1;
